#! /usr/bin/awk -f
#
# Programm für die erste Aufgabe der Vorlesung "Advanced practical Programming
# for Scientists"

# Besonderheit: Das geometrische Mittel wird durch Bilden des arithmetischen Mittels
# des Logarithmus gebildet. Das führt bei sehr vielen Eingabedaten dazu, dass viele
# kleine Zahlen (~10) zu einer immer größer werdenden Zahl addiert werden (~10^8).
# Darunter leidet die Genauigkeit, insbesondere, da mit dem arithmetischen Mittel
# potenziert wird. Darum lege ich eine Anzahl von Teilsummen an, die jede
# für sich nicht so groß werden. Die Gesamtsumme wird am Ende berechnet.
# Der Test zeigt, dass sich bei 1000 Teilsummen die Genauigkeit ab der 13.
# Nachkommastelle erhöht. Speicherverbrauch: 16kB.

# Eingabe erfolgt implizit durch Dateinamen nach Aufruf.
#-------------------------------------------------------

# Deklarationen
#---------------
BEGIN \
{
  FS=";"  # Feldtrenner
  Teilsummenanzahl = 1000
  Zeilenanzahl[1] = 0
  Zeilenanzahl[2] = 0
  Logarithmen_Teilsumme[1][0] = 0 # Zweidimensionales Feld anlegen.
  Logarithmen_Teilsumme[2][0] = 0 # Die Elemente sind mit Null vorgelegt.
  Logarithmensumme[1] = 0
  Logarithmensumme[2] = 0
  geom_Mittelwert[1] = 0
  geom_Mittelwert[2] = 0
}

# Verarbeitung
#-------------

# AWK geht alle Zeilen durch.
{
  # Bereite die Zeile vor. Ich könnte die Leerzeichen am Anfang und Ende
  # der Zeilen und vor und nach den Semikola löschen, aber das würde den
  # Kode viel langsamer machen, als wenn ich die Leerzeichen in den
  # regulären Ausdrücken ignorierte.
  #
  # Entfern alles nach einer Raute, weil sie einen Kommentar einleitet.
  gsub ("#.*$", "", $0);

  # Jede Zeile muss aus drei Datenfeldern bestehen.
  if(NF != 3) next;

  # Prüf das erste Datenfeld: muss natürliche Zahl sein.
  # Ich prüfe nicht, ob sie tatsächlich fortlaufend ist.
  if($1 !~ "^[[:space:]]*[0-9]+[[:space:]]*$") next;

  # Prüf zweites Datenfeld.
  if($2 ~ "^[[:space:]]*[12][[:space:]]*$") \
    Position = $2 + 0 # Da es Leerzeichen gibt, mit " + 0" in eine Zahl umwandeln.
  else
    next;

  # Prüf drittes Datenfeld. Nichtnegative Gleitkommazahl durch regulären Ausdruck.
  if($3 ~ "^[[:space:]]*[0-9]*(\\.[0-9]*)?([Ee][+-]?[0-9]+)?[[:space:]]*$") \
    aktuelle_Zahl = $3 + 0.0  # "0.0" für Gleitkommazahl.
  else
    next;

  # Diese Zeile scheint in Ordnung zu sein.
  Zeilenanzahl[Position]++;
  # Vereinfachung: arithmetisches Mittel der Logarithmen ist der
  # Logarithmus des geometrischen Mittels.
  # Addiere zu jener Teilsumme, die der Zeilennummer modulo Anzahl entspricht.
  Nummer_Teilsumme = Zeilenanzahl[Position] % Teilsummenanzahl;
  Logarithmen_Teilsumme[Position][Nummer_Teilsumme] += log(aktuelle_Zahl);
}

END \
{
  # Aufsummieren der Teilsummen
  for(i = 0; i < Teilsummenanzahl; i++)
  {
    Logarithmensumme[1] += Logarithmen_Teilsumme[1][i];
    Logarithmensumme[2] += Logarithmen_Teilsumme[2][i];
  }

  # Umrechnen des Mittelwertes der Logarithmen in geometrischen Mittelwert.
  if(Zeilenanzahl[1] >= 1)
    geom_Mittelwert[1] = exp(Logarithmensumme[1] / Zeilenanzahl[1]);
  else
    geom_Mittelwert[1] = 0;

  if(Zeilenanzahl[2] >= 1)
    geom_Mittelwert[2] = exp(Logarithmensumme[2] / Zeilenanzahl[2]);
  else
    geom_Mittelwert[2] = 0

  # Ausgabe
  #--------
  printf "File: %s with %d lines.\n", FILENAME, NR
  printf "Valid values Loc1: %d with GeoMean: %.12f\n",  Zeilenanzahl[1], geom_Mittelwert[1]
  printf "Valid values Loc2: %d with GeoMean: %.12f\n",  Zeilenanzahl[2], geom_Mittelwert[2]
}


# Ausgabe des Programms:
########################
#File: ex1.dat with 100001235 lines.
#Valid values Loc1: 50004466 with GeoMean: 36.781736117270
#Valid values Loc2: 49994581 with GeoMean: 36.782583200332

#real    5m31.150s
#user    5m30.904s
#sys     0m0.232s
